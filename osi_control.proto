syntax = "proto2";

option optimize_for = SPEED;

import "osi_common.proto";

package osi3;

//
// \brief This format is thought to control stand-alone parts of a simulation (e.g. a graphics-application).
//
message Control
{
    //
    // The interface version used by the sender.
    //
    optional InterfaceVersion version = 1;
    
    // The data timestamp of the simulation environment. The zero time point is
    // arbitrary but must be identical for all messages.
    // Recommendation: Zero time point for start point of the simulation.
    //
    optional Timestamp timestamp = 2;

    // ID-Number of the sending application.
    //
    optional uint32 application_sender_id = 3;
    
    // The application is the master (true). Otherwise the slave (false).
    //
    optional bool is_master = 4;
    
    // The state of the application.
    //
    optional ApplicationStateDefinition application_state = 5;
    
    // The frames per second.
    //
    optional double fps = 6;
    
    // The duration of the ping.
    //
    // Unit: [ms]
    //
    optional double ping = 7;

    // Possibility to inform about an error, warning or just to give an information.
    //
    // \note It is implementation-specific which information should be sent.
    //
    repeated Notification notification = 8;

    // All active or inactive events.
    //
    repeated Event event = 9;
    
    // Possibility to send commands regarding the target state of a specific application.
    // \note Not neccessary if the external application(s) just follow(s) the application_state of the master.
    //
    repeated ApplicationStateCommand application_state_command = 10;
}

// 
// \brief Definition of possible application-states.
// These are also used as commands in the message ApplicationStateCommand.
//
message ApplicationStateDefinition
{
    // The state of an application.
    //
    optional ApplicationState application_state = 1;
    
    // Definition of possible application-states.
    //
    enum ApplicationState
    {
        // The application is created and alive.
        //
        APPLICATION_STATE_UNKNOWN = 0;
        
        // The application is created and alive.
        //
        APPLICATION_STATE_OTHER = 1;
        
        // The application is created and alive.
        //
        APPLICATION_STATE_ALIVE = 2;

        // The application is initializing.
        // Transition: STATE_ALIVE ==> STATE_INITIALIZED
        //
        APPLICATION_STATE_INITIALIZING = 3;

        // The application is initialized.
        //
        APPLICATION_STATE_INITIALIZED = 4;

        // The application is starting.
        // Transition: STATE_INITIALIZED ==> STATE_RUNNING
        //
        APPLICATION_STATE_STARTING = 5;

        // The application is running.
        //
        APPLICATION_STATE_RUNNING = 6;

        // The application is paused.
        //
        APPLICATION_STATE_PAUSED = 7;

        // The application is stopped.
        // Transition: STATE_RUNNING ==> STATE_INITIALIZED
        //
        APPLICATION_STATE_STOPPED = 8;

        // The application is resetting.
        // Transition: STATE_INITIALIZED ==> STATE_ALIVE
        // Transition: STATE_RUNNING ==> STATE_ALIVE
        // Transition: STATE_FAILED ==> STATE_ALIVE
        //
        APPLICATION_STATE_RESETTING = 9;

        // An Error occured in the application.
        //
        APPLICATION_STATE_FAILURE = 10;
    }
}

// 
// \brief Definition of possible commands regarding the target state another application should have.
//
message ApplicationStateCommand
{
    // ID-Number of the receiver-application.
    //
    optional uint32 application_receiver_id = 1;
    
    // This is the target state the receiver-application should have or change to.
    //
    optional ApplicationStateDefinition application_state_command = 2;
}

// 
// \brief Possibility to send a notification.
// Can be used to send e.g. error-messages.
//
message Notification
{
    // The content of the notification.
    //
    optional string notification = 1;

    // Defines the type of the notification.
    //
    optional NotificationType notification_type = 2;
    
    // Definition of possible notification-types.
    //
    enum NotificationType
    {
        // The type is unknown.
        //
        NOTIFICATION_TYPE_UNKNOWN = 0;
        
        // It is another type.
        //
        NOTIFICATION_TYPE_OTHER = 1;
        
        // An error occurred.
        //
        NOTIFICATION_TYPE_ERROR = 2;

        // The notificiation is a warning.
        //
        NOTIFICATION_TYPE_WARNING = 3;

        // The notificiation is just an information.
        //
        NOTIFICATION_TYPE_INFORMATION = 4;

        // The notificiation is used for debugging.
        //
        NOTIFICATION_TYPE_DEBUG = 5;
    }
}

// 
// \brief Possibility to trigger an event.
//
// \note It is implementation-specific which event is triggered.
//
message Event
{
    // The number/id of an event.
    //
    optional uint32 eventnumber = 1;

    // The value (true=active, false=inactive) of an event.
    //
    optional bool is_active = 2;
}
